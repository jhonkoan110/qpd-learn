Любой объект(функции, массивы, объекты, специальные объекты) создаётся с помощью функции-конструктора.
За кадром это происходит со словом 'new'.

У любого объекта(и примитива) есть свойство __proto__.
У одинаковых типов данных эти __proto__ равны.

У всех видов функций(Function Declaration, Function Expression, Arrow Function, Class) __proto__ равны.

Чтобы понять, какой именно перед нами __proto__, нужно посмотреть с помощью какой функции-конструктора(класса) был создан данный объект.

Класс - это та же функция-конструктор, но более навороченная, удобная, со своими фишками.

Любой класс или любой function имеет prototype.
Object с большой буквы - это встроенный КЛАСС. Поэтому у него есть не только __proto__, но и prototype.

Каждый prototype - это независимый объект, сам по себе, со своим набором свойств и методов.
2 prototype никогда не будут равны. То если это не один и тот же prototype. У каждой функции, у каждого класса СВОЙ ПЕРСОНАЛЬНЫЙ prototype.
Object.prototype никогда не будет равен Array.prototype.
У каждого класса свой собственный prototype. Они не равны.

__proto__ - у любого объекта(у примитива, функции, объекта, массива, чего угодно)
prototype - y классов и функций (class && function). У стрелочной функции его нет. Он есть только у функций, объявленных с помощью слова function.

//======================================================================
__proto__ любого объекта ссылается на prototype класса(функции-конструктора), с помощью которой этот объект был создан.
=======================================================================//


ЗАЧЕМ КЛАССУ НУЖЕН объект prototype?
И зачем объектам, созданным с помощью этого класса, свойство __proto_, которое ссылается на этот объект prototype?

1) Для того, чтобы можно было клепать однотипные объекты.
2) Если попытаться прочитать свойтсво объекта или вызвать у него метод, а этого свойства/метода у этого объекта нет, то объект полезет искать свойство/метод через 
ссылку __proto__ в prototype своего класса, с помощью которого он был создан.

Поэтому когда я создаю свой класс(функцию-конструктор), методы можно вешать на prototype этого класса.
Например:

        function User(name) {
            this.name = name;
        }

        User.prototype.hello = function() {
            alert(this.name);
        }

        let user = new User('Kirill');
        user.hello(); // user.__proto__ => User.prototype, находит там метод hello

        let user2 = new User('Anton');
        user2.hello(); // user2.__proto__ => User.prototype, находит там метод hello

При этом ---------------------------------------------------------

        user.__proto__ === user2.__proto__

----------------------------------------------------------------------
потому что они оба ссылаются на один prototype.   User.prototype   :)


В настоящее время используется такая запись класса:

        class User {
            constructor(name) {
                this.name = name;
            }

            hello() {
                alert(this.name);
            }
        }

        let user = new User('Kirill');
        user.hello(); // Kirill

Эта запись идентична той, которая выше.


